#도커, 컨테이너 빌드업!

[이론]

- vm과 docker차이  
  => vm은 우리가 사용하는 운영체제 위에 아예 새로운 운영체제를 설치  
  => 도커는 우리가 사용하는 운영체제 위에 새로운 운영체제를 설치 시 공유되는 부분은 사용하고 나머지 없는 부분만 일부 탑재하는 것이다.

[명령어]

- -d 옵션  
  => 백그라운드에 컨테이너 실행 ex) run -itd OR run -it -d
  => ex) -d가 있으면, 한 cmd 창에서 다른 명령어(docker ps, docker logs 등)를 사용가능  
   ex) -d가 없으면, 이 cmd 창에서 켜지기 때문에 다른 명령어를 사용하고 싶다면 새로운 cmd창을 열어야한다.
- apt-get install -y "패키지"  
  => -y옵션은 설치 시 나타나는 모든 물음에 yes를 허용하겠다는 옵션
- -p 외부접속port:내부port 옵션
  ex) -p 3000:2888 3000포트로 접속하면 컨테이너 내부에서는 2888포트가 응답된다.
- --name 이름  
  => 컨테이너에 이름 지정 (안하면 랜덤으로 도커가 생성함)
- --restart=on-faulure  
  => 오류로 인해서 종료 되면 자동 재시작이 된다.
- docker exec -it [접속할 컨테이너 이름] bash
  => 켜져있는 컨테이너 접속할 때 쓰는 명령어, 마지막에 bash는 bash shell을 쓰겠다는 의미

[dockerfile]

- 서버 구성 복제 방법

1. 컨테이너 생성 및 실행 후 내부에서 직접 환경 구성을 해서 이미지 생성(167p)  
   컨테이너 생성 => A컨테이너를 베이스 이미지로 활용 => A이미지로 run it 해서 컨테이너 생성(167p) => 단, 컨테이너 생성 시 자동으로 서비스 시작 되지 않음 => dockefile을 만들어서 A이미지를 넣으면 컨테이너 생성 시 서비스 자동 시작 됨(번거로움)
2. dockerfile에 담아서 생성

- Dockerfile에 작성한 명령을 순서대로 읽는다.
- dockerfile은 사용자의 개입이 없는(사용자와의 대화식 처리가 아닌) 자동화된 빌드이다. => 패키지 설치 시 반드시 -y 옵션을 사용해야한다.
- Dockerfile보다 상위 디렉토리에 위치한 파일을 COPY 할 수 없다. Dockerfile랑 같거나 하위에 있어야한다.

- Buildkit

1. Buildkit를 추가하면 도커파일 이미지 빌드에 향상된 기능을 제공한다.
2. 특징  
   => 빌드 과정을 병렬 처리하여 더 빠른 빌드 제공  
   => 사용되지 않는 빌드 단계를 찾아서 비활성화  
   => 비밀번호 등의 민감한 데이터가 포함되는 경우 비밀 구축이 가능  
   => 빌드 중 빌드 정보에 따라 변경된 파일만 전송  
   => 자동 빌드 시 빌드 캐시의 우선순위를 정한다.
3. 사용 방법 DOCKER_BUILDKIT=1  
   => ex) DOCKER_BUILDKIT=1 docker build -t ~~~

[도커 컴포즈]

- 정의  
  => 공통성을 갖는 컨테이너 애플리케이션 스택을 YAML 코드로 정의하는 정의서이며 그것을 실행하기 위한 다중 컨테이너 실행 도구다.  
  => 테스트, 개발, 운영의 모든 환경에서 구성이 가능한 오케스트레이션 도구 중 하나이다. 다만 다양한 관리 기능은 없어서 테스트와 개발환경에 적합하다. 실제 운영 환경은 많은 관리적 요소가 필요해서 도커 스웜이나 쿠버네티스와 같은 오케스트레이션 도구가 가지고 있는 자동 확장, 모니터링, 복구 등의 운영에 필요한 기능과 함께 사용하는 것을 권장한다.  
  ex) 프론트는 리액트, 백엔드는 자바, 데이터베이스는 MySQL을 사용한다고하면 이 3가지 컨테이너를 YAML 코드에 정의해서 한 번에 서비스를 올리고 관리할 수 있는 도구가 도커 컴포즈이다.

- 작성 방법

1. 버전 정의

- 도컴 컴포즈와 도커 엔진 릴리스는 적합한 버전이 있기 때문에 버전 호환이 가능한지 확인해봐야 한다.

2. 서비스 정의
3. 네트워크 정의
4. 볼륨 정의

- 의문 및 해결

1. docker-compose에 frontend의 ports "3000:3001"했더니, react 화면이 계속 안 뜸.  
   => "3000:3000"으로 했더니 화면이 뜸.  
   => 리액트 기본 포트가 3000으로 잡혀있기 때문에 컨테이너 포트를 3000으로 설정해야 한다.

2. Frontend 도커파일에서 WORKDIR먼저 작성 후 RUN npm install을 작성해야하는 이유.
   => workdir을 설정하면 run명령이 해당 파일에서 실행된다. npm install의 경우 프로젝트 디렉터리에 생성되어야하는 node_modules 디렉터리에 패키지를 설치하기 때문에 중요하다. => 한 프로젝트 디렉터리 내에서만 사용 가능하도록 하는게 좋으니깐(그래야 여러 프로젝트 생성 시 버전 충돌이 안될테니깐)

3. Nginx expose port 80 외에도 443을 넣는 이유.  
   => 향후 https를 사용할 수도 있기 때문이다.

4. Nginx - default.conf

```
upstream frontend {
  server frontend:3000; //여기서 frontend는 docker-compose에 설정해둔 컨테이너 이름이다.(server ip:포트)
}
```

=> server ip:port를 적는 것인데 컨테이너의 ip가 필요하기 때문에 컨테이너 이름을 설정해야한다.

5. SpringBoot애플리케이션을 jar파일로 빌드할 때 db접속 정보 분리  
   => 이터베이스 접속 정보를 하드코딩하지 않고 외부 설정으로 관리하는 것이 좋다. 도커 컨테이너를 실행할 때마다 유연하게 다른 데이터베이스 연결 정보를 사용할 수 있기때문이다.

   - Spring Boot는 다음과 같은 우선 순위로 설정 파일을 읽는다.  
      외부 설정 파일 (application.properties 또는 application.yml) -> 환경변수 (Environment Variables) -> 기본 내장 설정

6.
